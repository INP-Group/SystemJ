<HTML>
<HEAD>
<TITLE>Формат файла blklist.lst</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="style.css">
</HEAD>
<BODY>

<H1>Формат файла <TT>blklist.lst</TT></H1>

<H2>Введение</H2>

<P>В данном документе описывается структура файла <TT>blklist.lst</TT>, в
котором перечисляется список блоков/драйверов для cx-сервера.  По
умолчанию cx-сервер использует файл <TT>./blklist.lst</TT>, но можно
указать другой файл ключом "<CODE>-f</CODE>" при запуске cxd.

<P>Поскольку сам текстовый файл <TT>blklist.lst</TT> появился не от
хорошей жизни -- вследствие отсутствия пока базы данных, и является ее
суррогатом, то в будущем значение ключа "<CODE>-f</CODE>" изменится --
он будет указывать адрес базы данных (по-видимому, это будет ссылка на
таблицу PostgreSQL, например, вида
"hostname:port/databasename/tablename").


<H2>Общие положения</H2>

<P><TT>blklist.lst</TT> является текстовым файлом.  Пустые строки
игнорируются, так же как и строки, начинающиеся с "<TT>#</TT>" --
комментарии.  Символы табуляции эквивалентны пробелам, множественные
последовательные пробелы считаются одним пробелом (за исключением поля
auxinfo, интерпретация которого определяется конкретным драйвером).


<H2>Формат</H2>

<P>Каждая строка описывает один блок. Строка состоит из 6 полей,
разделенных пробелами <I>(опциональное нулевое поле пробелом не
отделяется)</I>.  Последнее поле -- <CODE>auxinfo</CODE> -- является
опциональным, и продолжается до конца строки, так что может само
содержать пробелы (хотя это не рекомендуется).

<P>Формат строки следующий:

<BLOCKQUOTE CLASS=excerpt><PRE>
[:NAME:]file driver bus_id main_info bigc_info auxinfo
</PRE></BLOCKQUOTE>


<P>Назначение полей:

<DL>

<DT>:NAME: <DD>опциональное имя экземпляра устройства.  В случае
указания должно быть окружено двоеточиями; между закрывающим двоеточием
и следующим полем НЕ должно быть пробелов.

<DT>file <DD>имя файла драйвера; к нему автоматически добавляется
"<TT>_drv.so</TT>". <!-- При использовании "слоев доступа к аппаратуре"
(hardware access layers) может иметь вид "<TT>file@layer</TT>", где
"<TT>layer</TT>" -- имя уровня, требуемого драйверу; к нему
автоматически добавляется "<TT>_layer.so</TT>". -->

<DT>driver <DD>имя записи-описания драйвера в файле, определяемой в
исходном тексте драйвера первым параметром макроса
<CODE>DEFINE_DRIVER()</CODE>.  В настоящее время в одном файле _drv.so
может содержаться несколько драйверов -- это было сделано для
возможности создавать "связанные" драйверы, т.е. такие, которые
совместно используют некоторые ресурсы. <!-- Реально эта возможность не
используется, и когда будет реализована реальная поддержка "слоев
доступа к аппаратуре", сия фича множественных драйверов исчезнет.-->

<DT>bus_id <DD>числовой идентификатор блока "на шине".  Например,
козак-адрес блока на шине CANBUS, позиция в CAMAC-крейте и т.д.

<P>При необходимости использования двойного адреса (например, связка
Липка+КАС-128, которой требуется 2 позиции), адреса указываются через
запятую. <!-- При этом собственно значение bus_id будет
<CODE>N1+N2*256</CODE>.  В частности драйверы стандарта uclinux/i_mtrlr
пользуются этим соглашением.  Можно указать до четырех "подадресов",
которые в значении bus_id займут байты с нулевого по третий.-->

<P>Если для адресации недостаточно этого поля (например, требуется еще
имя/IP-адрес контроллера), то следует для указания дополнительной
информации пользоваться полем auxinfo.

<DT>main_info <DD>информация об основных ("обычных") каналах блока (см.
ниже); если драйвер не поддерживает "основные" каналы, в этом поле
должен стоять "<TT>-</TT>".

<DT>bigc_info <DD>информация о "больших" каналах (см. ниже); если
драйвер не поддерживает "большие" каналы, в этом поле должен стоять
"<TT>-</TT>".

<DT>auxinfo <DD>дополнительная информация, смысл которой определяется
драйвером. Cx-сервер не пытается просматривать это поле, а просто
передает его драйверу.  Поле auxinfo простирается до конца строки.

</DL>

<H3>main_info</H3>

<P>Формат поля main_info следующий:

<BLOCKQUOTE CLASS=excerpt><PRE>
Tnnn{,Tnnn}
</PRE></BLOCKQUOTE>

Где T -- тип каналов ("<TT>r</TT>" -- каналы чтения, "<TT>w</TT>" --
каналы чтения/записи), а nnn -- их количество.  Если блок поддерживает
несколько разнородных наборов каналов, то эти наборы указываются через
запятую (вокруг запятой не должно быть пробелов!).

<P>Пример 1: ЦАП-16/16:

<BLOCKQUOTE CLASS=excerpt><CODE>w16</CODE></BLOCKQUOTE>

<P>Пример 2: ИВА-16 (по 16 каналов чтения токов, чтения напряжений,
уставок пределов токов, уставок пределов напряжений):

<BLOCKQUOTE CLASS=excerpt><CODE>r16,r16,w16,w16</CODE></BLOCKQUOTE>

<P>Пример 3: козаковский CAN-ADC-40 (40 каналов чтения АЦП, 8 каналов
записи УР'а, 8 каналов чтения СДС'а):

<BLOCKQUOTE CLASS=excerpt><CODE>r40,w8,r8</CODE></BLOCKQUOTE>


<H3>bigc_info</H3>

<P>Формат поля bigc_info следующий:

<BLOCKQUOTE CLASS=excerpt><PRE>
numchans*nargs+datasizeU/ninfo+retdataU
</PRE></BLOCKQUOTE>

Здесь "numchans" -- количество каналов, а далее идет описание свойств
каналов.  "nargs" -- количество int32-параметров, "datasize" --
количество входных единиц информации, а символом U указывается тип этих
единиц: "<TT>b</TT>" -- байты, "<TT>s</TT>" -- 16-битные слова
(shortints), "<TT>i</TT>" -- 32-битные слова (ints).  "ninfo" и
"retdata" аналогично описывают возвращаемую каналом информацию.

<P>Пример (гипотетический):

<BLOCKQUOTE CLASS=excerpt><CODE>3*2+10s/4+40i</CODE></BLOCKQUOTE>

Здесь описывается блок, поддерживающий три больших канала, каждый из
которых в качестве входной информации принимает 2 параметра int32 и 10
16-битных слов, а возвращает 4 слова int32 и 40 слов int32.

<P>Еще пример (двухканальный контроллер ИПП-32 by Репков):

<BLOCKQUOTE CLASS=excerpt><CODE>28*2+0i/2+30s</CODE></BLOCKQUOTE>

<P>Если блок поддерживает несколько разнородных наборов больших каналов,
то эти наборы, аналогично "основным" каналам, указываются через
запятую.

</BODY>
</HTML>

