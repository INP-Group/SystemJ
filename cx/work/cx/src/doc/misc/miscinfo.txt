	ВСЯКИЕ РАЗНОСТИ

        1. Сервер: трехпроцессность vs. однопроцессность

Достоинства трехпроцессности:

- основное достоинство -- фрагментация: каждый процесс занимается своим
  собственным делом.  Это позволило, например, сделать *маленький*
  cx-porter и провести его детальный аудит, так что теперь он
  bullet-proof;

- если одна часть (например, cx-porter) по какой-либо причине сдурела,
  на работоспособности cx-server'а это номинально не скажется.

Недостатки трехпроцессности:

- детей надо порождать, передавая им кучу параметров (дескрипторы для
  logging'а, environment, etc.), в результате ForkPart() -- очень
  большая и мерзковатая;

- о детях надо заботиться -- проверять, не померли ли (ловить SIGCHLD,
  делать wait), их надо пришибать перед exit();

- трехпроцессная программа "неатомарна" -- нельзя сделать kill -STOP
  одним махом всем сразу; одна из частей может глюкануть и сдохнуть, а
  остальные останутся "сиротами";

- передавать готовый дескриптор клиента из cx-porter в cxd/cx-server
  приходится при помощи sendmsg(), а это весьма нетривиальная
  манипуляция (*масса* "танцев с бубнами"), плюс у recvmsg() есть
  какой-то глюк с возвратом 0 по закрытому дескриптору -- он вместо
  возврата 0 продолжает висеть и ждать;

- в cx-server и cxd получается дублирование *похожего* кода -- я сделал
  библиотеку, но они неидентичны, и дублирование остается;


Почему решено отказаться от трехпроцессности в пользу однопроцессности:

Захотелось сделать "frontend plugins" для сервера: т.е., протокол
доступа к серверу -- не только cx, но и произвольный (например, CORBA).
А трехпроцессная идеология была заточена именно под cx.  Более того,
сделать cx-access-plugin в трехпроцессной архитектуре невозможно в
принципе -- понадобятся отдельные плагины в cx-server и cx-porter. Это
и стало "последней каплей".

Тем не менее, многопроцессность позволила четко разделить функции этих
подсистем, так что в будущем варианте оно будет так же "раздельно" по
.c-файлам.


	2. Аналогия CX <-> X11

По своему устройству CX-сервер и X-сервер очень похожи: оба управляют
неким набором сущностей, манипуляция конкретными экземплярами которых
производится через конкретные драйверы, и предоставляют внешним
клиентам через себя разделяемый доступ к этим сущностям
(абстрактноватая формулировочка, n'est pas?).

Какие были в CX использованы архитектурные решения, подсмотренные в
X11/XFree86:

- Множественные сервера -- они именуются как HOSTNAME:N, где N -- номер
  сервера.  При этом optional являются обе части, т.е. если в X
  спецификация "[hostname]:displaynumber[.screennumber]", то в CX --
  "[hostname][:servernumber]" (аналог screennumber'а отсутствует за
  ненадобностью).  При неуказании сервера используется $CX_SERVER
  (аналог $DISPLAY), при неустановленности оной -- localhost:0.

- В отдаленной перспективе стоит необходимость поддержки IPv6. 
  Аналогичная проблема уже осознана в XFree86/X.org, с похожими
  препятствиями (":" используется для указания экземпляра сервера, но в
  адресах IPv6 оно же играет роль разделителя в числовой нотации
  аналогично "." в IPv4).  К моменту, когда появится реальная
  необходимость, в X уже будет готовое решение, которым можно будет
  воспользоваться.

  [23.02.2005] А кроме того, в X11 уже сейчас есть shared memory
  extension, и, похоже, вскоре Sun'ом будет открыт код shared memory
  transport, каковой был бы чрезвычайно полезен для передачи больших
  объемов данных в CX (например, видео) -- т.н. "zero copy".

- Существует задача взаимодействия клиентов и серверов с разным
  порядком байт.  В X11 конверсия делается на стороне сервера, в CX
  сейчас -- на стороне клиента, но явно стоит пойти путем X -- это
  удобнее.

- Поддержка драйверов: по образу XFree86-4.x в CX была введена
  поддержка загружаемых модулей (при помощи dlopen()).  В ближайшем
  будущем этот подход будет углублен -- загружаемыми станут и
  frontend'ы -- модули доступа, что позволит кроме протокола CX
  пользоваться, например, CORBA, RPC (да хоть COM/COM+), что даст
  возможность портировать CX под Win32.

- Что интересно, по аналогии с XFree86 можно также будет делать
  "статические сервера", для платформ, не поддерживающих dlopen():
  нужные драйвера просто влинковываются at compile time.

- Структура директорий: вследствие похожести по функциям и по составу,
  в CX используется аналогичная X11 как структура исходных директорий
  (xc/), так и инсталлированного дерева (/usr/X11R6/).

- В прикладных утилитах можно использовать схему именования вида
  "ПРОТОКОЛ/АДРЕС" (X11: tcp/sky:7100, unix/:-1; CX: cx/linac1:5,
  tsycam/192.168.6.10:4001).

- [23.02.2005] В ноябре/декабре 2004г. в xorg@.org была жаркая
  дискуссия на тему "xc/programs considered harmful" -- как раз о том,
  что надо все дерево сделать модульным.  У нас же в CX эта проблема
  осознана давно и надлежащая инфраструктура создана осенью 2003г.
