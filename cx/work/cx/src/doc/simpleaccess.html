<HTML>
<HEAD>
<TITLE>Подсистема "простого" доступа к данным в CX "simpleaccess"&nbsp;&#151; краткое описание</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="style.css">
</HEAD>
<BODY>


<H1>Подсистема "простого" доступа к данным в CX "simpleaccess"&nbsp;&#151; краткое описание</H1>

<H2>Общие сведения</H2>

<H3>Причина появления модуля simpleaccess</H3>

<P>Исторически архитектура CX устроена таким образом, что существенная
часть действий выполняется на стороне клиентов (что нормально), но
значительную часть информации приходится "зашивать" в клиентские
программы (что плохо).

<P>К проблемной информации относятся:

  <OL>

  <LI>Имена каналов: внутри CX адресация идёт по номерам, которые со
временем могут меняться, а система именования с резолвингом в номера в
сервере версии v2 таки и не появилась.

  <LI>Пересчёт из инженерных величин в операторские: большинство
каналов отдаются 32-битовыми целыми числами (в основном -- в
микровольтах), и пересчёт этих значений в отображаемые операторские
величины (токи, температуры, поля, ...) возложен на клиентов, но
коэффициенты пересчёта также приходится зашивать, поскольку вместе с БД
по именам в сервере версии v2 отсутствует и БД пересчёта.

  </OL>

<P>Если для пультовых "экранов" такой подход хоть с натяжкой, но
приемлем, то для прочей работы ("самодельные" простые
программы-крутилки, система журналирования и т.д.) он создаёт огромные
неудобства.

<P>В будущей версии v4 проблемы будут устранены изначально, но для
нынешней версии требовалось какое-то промежуточное решение, которое бы
позволило иметь удовлетворительный доступ к данным CX без излишних
выкрутасов.


<H3>Принцип работы</H3>

<P>Поскольку вся требуемая информация УЖЕ содержится в "экранах"
пультовых программ, то можно брать её оттуда.  Описания экранов
содержатся в файлах с суффиксом "<TT>_db.so</TT>" (например,
<TT>linmagx_db.so</TT> -- магнитная система линака).  Полноценные
клиенты на пульту (а также cx-starter) загружают эти описания и
запускают их работать.  Ровно это же позволяет делать и модуль
simpleaccess.

<P>В корректно описанных экранах каждая ручка в иерархии имеет свой
идентификатор, позволяющий (вместе с полным путём в дереве до этой
ручки) адресоваться к ней: читать текущее значение, запрашивать запись
значения (для read-write-ручек/каналов), указывать callback, вызываемый
по приходу нового значения.

<P>Каналы в описаниях снабжены информацией о переводе между инженерными
величинами (int32, микровольты) и операторскими (double,
токи/температуры/...).  Таким образом, вместе с проблемой адресации
автоматически решается и задача перевода.


<H3>Место simpleaccess в иерархии клиентских библиотек</H3>

<P>Модуль simpleaccess является частью библиотеки Cdr (Cx Data
Representation), обеспечивающей "жизнедеятельность" экранов пультовых
программ <I>(за отображение данных отвечает библиотека более высокого
уровня Chl (Cx High-Level))</I>.

<P>Cdr, в свою очередь, пользуется услугами библиотеки cda (Cx Data
Access), производящей конверсию данных <I>(в т.ч. нетривиальные
преобразования при помощи т.н. "формул", являющихся простым стековым
языком программирования)</I> и поддерживающей соединения с серверами, с
автоматическим восстановлением связи при обрыве (сбои сети, перезапуски
серверов, и т.п.).

<P>На самом нижнем уровне работает транспортная библиотека cxlib,
реализующая сетевой протокол общения с серверами.


<H2></H2>


<H2>API и использование</H2>

<P>Определения для simpleaccess содержатся в файле <TT>Cdr.h</TT>, в
конце.

<P>Для работы к программе следует подшить библиотеки <TT>libCdr.a</TT>,
<TT>libdatatree.a</TT>, <TT>libcda.a</TT>, <TT>libcx_async.a</TT>,
какую-либо реализацию cxscheduler (<TT>libcxscheduler.a</TT>,
<TT>libXh_cxscheduler.a</TT>, <TT>libQcxscheduler.a</TT> -- в
зависимости от используемого окружения), <TT>libuseful.a</TT>,
<TT>libmisc.a</TT> -- именно в таком порядке.

<P>Описания экранов -- файлы <TT>_db.so</TT> -- должны быть где-либо в
доступности: либо в текущей директории (<TT>./</TT>), либо в директории
с программой (если она запускается с полным указанием пути к ней), либо
<TT>$HOME/pult/lib/</TT>, либо в директории, на которую указывает
переменная окружения <TT>CHLCLIENTS_PATH</TT>.


<H3>Общий подход</H3>

<P>Поскольку скалярные и большие каналы значительно отличаются по
функционированию, то API работы с ними разделены.

<P>Однако в обоих случаях используется один принцип:

  <UL>

  <LI>Сначала канал регистрируется, путём указания его имени в формате
ПОДСИСТЕМА.ЭЛЕМЕНТ{.ПОДЭЛЕМЕНТ}.КАНАЛ.

<P>В этот момент можно указать callback, вызываемый по приходу данных
для этого канала), 

  <LI>Функция регистрации возвращает дескриптор (handle) -- уникальное
целое число, которое затем используется для всех операций с каналом
(чтение, запись) и передаётся callback'у.

  <LI>Также при регистрации можно указать private pointer -- указатель
типа <CODE>void*</CODE>, который будет передаваться callback'у.

  <LI>При успешном исполнении функции возвращают 0 (функции регистрации
-- дескриптор), при ошибке -- -1.

  </UL>

<P>Где брать имена каналов:

  <OL>

  <LI>Первый компонент полного имени канала -- "ПОДСИСТЕМА" -- это
название описания/экрана/группировки, то, что идёт до "_db.so". 
Например, в случае описания магнитной системы линака --
<TT>linmagx_db.so</TT> -- именем подсистемы является "linmagx".

  <LI>Путь к каналу внутри экрана -- цепочку "ЭЛЕМЕНТ{.ПОДЭЛЕМЕНТ}" --
можно посмотреть в обычном пультовом приложении, нажав на канале правую
кнопку мыши;  путь показывается в строке "Path".

  <LI>Имя самого канала показывается в строке "Name".  

  </OL>

<P>Возвращаемые функциями значения:

  <UL>

  <LI>Все функции возвращают либо <CODE>-1</CODE> при ошибке, либо
некое значение (если таковое имеет смысл), либо 0.

  <LI>Функции регистрации при успехе возвращают дескриптор канала.

  <LI>Функция вычитывания данных больших каналов возвращает объём
реально прочитанного, в байтах (может быть меньше запрошенного).

  </UL>


<H3>Скалярные каналы</H3>

<P>Регистрация скалярного канала производится функцией
<CODE>CdrRegisterSimpleChan()</CODE>:

<BLOCKQUOTE><PRE>
int   CdrRegisterSimpleChan(const char *name, const char *argv0,
                            CdrSimpleChanNewValCB_t cb, void *privptr);
</PRE></BLOCKQUOTE>

<P>Здесь <CODE>name</CODE> -- полное имя канала; <CODE>argv0</CODE> --
то, что передано программе в качестве argv[0] (используется для поиска
описаний); <CODE>cb</CODE> -- функция-callback (при указании
<CODE>NULL</CODE> ничего вызываться не будет); <CODE>privptr</CODE> --
private pointer для передачи callback'у.

<P>Функция-callback описывается типом
<CODE>CdrSimpleChanNewValCB_t</CODE>:

<BLOCKQUOTE><PRE>
typedef void (*CdrSimpleChanNewValCB_t)(int handle, double val, void *privptr);
</PRE></BLOCKQUOTE>

<P>Чтение и запись значения можно выполнить в любой момент при помощи
функций

<BLOCKQUOTE><PRE>
int   CdrSetSimpleChanVal  (int handle, double  val);
int   CdrGetSimpleChanVal  (int handle, double *val_p);
</PRE></BLOCKQUOTE>

<P><B>ЗАМЕЧАНИЕ:</B> поскольку система управления распределённая,
термин "запись" означает не <I>"выполни запись немедленно и чтоб я тебя
не видел, пока не будет исполнено"</I>, а ЗАКАЗ записи.  Реальное
исполнение произойдёт с некоей отсрочкой, и даже более того --
следующее вёрнутое значение будет с гарантией еще не то, что  запрошено
записать, а предыдущее текущее; и лишь ЧЕРЕЗ цикл, возможно, вернут
"то" (но может и позже -- зависит от скорости отработки железом).
Поэтому общее правило: программы должны быть АСИНХРОННЫМИ, никогда не
пытаться чего-то ждать "прям щас", а давать КОМАНДЫ и потом реагировать
на СОБЫТИЯ (например, изменение значения).


<H3>Большие каналы</H3>

<P>Большие каналы являются значительно более сложной сущностью, чем
скалярные, поэтому и API у них развесистее.  Помимо регистрации канала
функции делятся на 3 класса:

  <OL>

  <LI>Работа с векторными данными: чтение и (очень редкий случай)
запись.

  <LI>Работа с параметрами: чтение отдельного параметра и модификация
параметра.

  <LI>Считывание атрибутов "возраст" (age/tag) и "флаги" (rflags).

  </OL>

<P>Регистрация канала производится функцией

<BLOCKQUOTE><PRE>
int   CdrRegisterSimpleBigc(const char *name, const char *argv0,
                            size_t max_datasize,
                            CdrSimpleChanNewBigCB_t cb, void *privptr);
</PRE></BLOCKQUOTE>

<P>Большинство параметров аналогичны оным для скалярных каналов, а
<CODE>max_datasize</CODE> -- максимальный ожидаемый объём данных
большого канала в байтах (выделяется буфер такого размера). 
Функция-callback должна соответствовать типу

<BLOCKQUOTE><PRE>
typedef void (*CdrSimpleChanNewBigCB_t)(int handle,             void *privptr);
</PRE></BLOCKQUOTE>

(отличие от скалярного аналога в том, что ей НЕ передаются
свежеполученные данные).

<H4>1. Работа с векторными данными.</H4>

<P>Вычитывание текущих данных:

<BLOCKQUOTE><PRE>
int   CdrGetSimpleBigcData (int handle, int byte_ofs, int byte_size, void *buf);
</PRE></BLOCKQUOTE>

<P>Из вектора данных (считающегося куском памяти с байтовой адресацией)
фрагмент со смещением <CODE>byte_ofs</CODE> от начала и размером
<CODE>byte_size</CODE> копируется в буфер, на который указывает
<CODE>buf</CODE>.

<P>Правильная интерпретация данных -- как с точки зрения расположения в
общем буфере (например, данные отдельных измерительных каналов у
многоканальных цифровых осциллографов), так и с точки зрения типов
(1,2,4-байтовость) -- на совести программы.


<BLOCKQUOTE><PRE>
</PRE></BLOCKQUOTE>

<H4>2. Работа с параметрами.</H4>

<P>Чтение и запись одиночного параметра производятся функциями

<BLOCKQUOTE><PRE>
int   CdrGetSimpleBigcParam(int handle, int n, int *val_p);
int   CdrSetSimpleBigcParam(int handle, int n, int  val);
</PRE></BLOCKQUOTE>

соответственно.  В отличие от скалярных каналов, значения параметров --
целочисленные (внутреннее представление 32-битовое).

<P><B>ЗАМЕЧАНИЕ:</B> аналогично скалярным каналам, модификация
параметров больших каналов отрабатывается не мгновенно, а с задержкой. 
Причём, вследствие более сложного функционирования больших каналов,
задержка может составить не один, а несколько циклов.

<H4>3. Получение атрибутов.</H4>

<P>Функция


<BLOCKQUOTE><PRE>
int   CdrGetSimpleBigcStats(int handle, int *age_p, int *rflags_p);
</PRE></BLOCKQUOTE>

позволяет считать "возраст" значения канала и флаги.

  <UL>

  <LI>Возраст возвращается в секундах, и считается от момента измерения
до возврата значения сервером (т.е., время с последнего прихода данных
от сервера НЕ прибавляется, но при обрыве соединения возраст
сбрасывается в "бесконечность" -- 255).

<P>По факту в подавляющем числе случаев возраст будет равен 0 (за
исключением работы в режиме FROMCACHE, который пока модулем
simpleaccess не поддерживается).

  <LI>Флаги -- это 32-битовая маска, бОльшая часть которой заполняется
драйверами и сервером.  Список флагов -- константы, имена которых
начинаются на <CODE>CXRF_</CODE> и <CODE>CXCF_</CODE> (для серверных и
клиентских флагов соответственно) -- доступен в файле <TT>cx.h</TT>.

  </UL>

<BLOCKQUOTE><PRE>
</PRE></BLOCKQUOTE>


<H2>Доступ из python</H2>

[тут пока пусто, будет написано позже]


<H2></H2>


<H2></H2>


</BODY>
</HTML>
